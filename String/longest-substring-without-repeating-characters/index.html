<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

<script>
// 因为需要找无重复的子串，我们可以定义初始化的子串是第一个字符，也就是 `let newStr = str[0]`。
// 然后我们每次往后去加一个字符也就是str[i]。
// 这时候就需要判断str[i]是否在newStr中，并且知道它所在的位置，`let j = newStr.indexOf(str[i]);`。
// 如果j为-1就是newStr不存在str[i],就是把str[i]的数据加到newStr的后面，`newStr = newStr + str[i]`;否则，从j的位置删除前面的数据后，再加上str[i]，`newStr = newStr.substring(j+1,newStr.length);newStr = newStr + str[i]`
// 最后将存的最大值和当前的最大值比较。
// 循环上述操作，从而得出最后的最大值max。
// 确定好需要的变量：因为需要知道最长子串的长度，我们可以存两个变量，一个该字符串maxStr一个最大长度max；然后定义每次的字符串长度
const lengthOfLongestSubstring  = (str) => {
  let len = str?.length || 0
  if(!len || len == 1) return len 
  let max = 1
  let maxStr = ''
  let newStr = str[0]
  for(let i =1; i<len; i++ ){
    let j = newStr.indexOf(str[i]);
    if(j === -1){
      newStr = newStr + str[i]
    }
    if(j !== -1){
      newStr = newStr.substring(j+1,newStr.length)
      newStr = newStr + str[i]
    }
    max = max > newStr.length ? max : newStr.length
    maxStr = max > newStr.length ? maxStr : newStr
  }
  return max
}
</script>
</body>
</html>
